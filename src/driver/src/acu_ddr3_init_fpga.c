#include "acu_ddr_init_fpga.h"

void DDRC_FPGA_x8_Init(int chs);
static void ddr_fpga_training (void);

void DDRC_FPGAInit(void)
{
    uint8_t i = 0;
    uint32_t TempSet = 0;
    
    /* DDRC read dram_sel config */
    WRITE32(RST_SC->DDR_RCFG, 0x0);

    /* DDRC write dram_wcfg config */
    for (i = 0; i < DDRC_NUMBER; i++) 
    {
        TempSet |= (0x1 << i);
    }
    WRITE32(RST_SC->DDR_WCFG, TempSet);

    /* DDRC system management config */
    for (i = 0; i < DDRC_NUMBER; i++) 
    {
        /* set pub address non-compress mode */
        WRITE32(0x4008c024 + (i * 0x400), 0x4);
        /* release clock */
        WRITE32(0x4008c004 + (i * 0x400), 0x3f);
        /* release port2 reset bit[2], use for ddrphy pll reset */
        WRITE32(0x4008c000 + (i * 0x400), 0x3b);
        /* polling fpga phy pll lock */
        while((READ32(0x4008c0d4 + (i * 0x400)) & 0x4) != 0x4) ;
        /* release pubphy pwrokin */
        WRITE32(0x4008c000 + (i * 0x400), 0x1b);
        /* release umctl2 apb/debug reset */
        WRITE32(0x4008c000 + (i * 0x400), 0x13);
    }

    DDRC_FPGA_x8_Init(DDRC_NUMBER);
}

void DDRC_FPGA_x8_Init(int chs)
{
    int i = 0;

    // step 1 : Program the DWC_ddr_umctl2 registers 
    WRITE32 (UMCTL2_ADDR_BASE+0x0304 , 0x00000001);
    WRITE32 (UMCTL2_ADDR_BASE+0x0030 , 0x00000001);
    WRITE32 (UMCTL2_ADDR_BASE+0x0000 , 0x40040001);
    WRITE32 (UMCTL2_ADDR_BASE+0x0010 , 0x00003030);
    WRITE32 (UMCTL2_ADDR_BASE+0x0014 , 0x000053d6);
    WRITE32 (UMCTL2_ADDR_BASE+0x0020 , 0x00000020);
    WRITE32 (UMCTL2_ADDR_BASE+0x0024 , 0x88a5afe3);
    WRITE32 (UMCTL2_ADDR_BASE+0x0030 , 0x0000000a);
    WRITE32 (UMCTL2_ADDR_BASE+0x0034 , 0x000e3202);
    WRITE32 (UMCTL2_ADDR_BASE+0x0038 , 0x000b0003);
    WRITE32 (UMCTL2_ADDR_BASE+0x0050 , 0x0021c070);  // RFSHCTL0
    WRITE32 (UMCTL2_ADDR_BASE+0x0054 , 0x0019005c);
    WRITE32 (UMCTL2_ADDR_BASE+0x0060 , 0x00000000);
    WRITE32 (UMCTL2_ADDR_BASE+0x0064 , 0x000a801f);  // RFSHTMG
    WRITE32 (UMCTL2_ADDR_BASE+0x00c0 , 0x00000000);
    WRITE32 (UMCTL2_ADDR_BASE+0x00d0 , 0x40030006);
    WRITE32 (UMCTL2_ADDR_BASE+0x00d4 , 0x00010105);
    WRITE32 (UMCTL2_ADDR_BASE+0x00d8 , 0x00000c06);
    WRITE32 (UMCTL2_ADDR_BASE+0x00dc , 0x04200006);
    WRITE32 (UMCTL2_ADDR_BASE+0x00e0 , 0x00000000);
    WRITE32 (UMCTL2_ADDR_BASE+0x00e4 , 0x00110001);
    WRITE32 (UMCTL2_ADDR_BASE+0x00f4 , 0x00000366);
    WRITE32 (UMCTL2_ADDR_BASE+0x0100 , 0x078abd79);
    WRITE32 (UMCTL2_ADDR_BASE+0x0194 , 0x0004020a);
    WRITE32 (UMCTL2_ADDR_BASE+0x0108 , 0x03030609);
    WRITE32 (UMCTL2_ADDR_BASE+0x00f0 , 0x00000000);
    WRITE32 (UMCTL2_ADDR_BASE+0x010c , 0x00002007);
    WRITE32 (UMCTL2_ADDR_BASE+0x0110 , 0x03020204);
    WRITE32 (UMCTL2_ADDR_BASE+0x0114 , 0x01020302);
    WRITE32 (UMCTL2_ADDR_BASE+0x0118 , 0x00000000);
    WRITE32 (UMCTL2_ADDR_BASE+0x011c , 0x00000000);
    WRITE32 (UMCTL2_ADDR_BASE+0x0120 , 0x03030802);
    WRITE32 (UMCTL2_ADDR_BASE+0x0180 , 0x60800020);
    WRITE32 (UMCTL2_ADDR_BASE+0x0184 , 0x00000170);
    WRITE32 (UMCTL2_ADDR_BASE+0x0188 , 0x00000000);
    WRITE32 (UMCTL2_ADDR_BASE+0x0190 , 0x03050001);
    WRITE32 (UMCTL2_ADDR_BASE+0x0194 , 0x00020102);
    WRITE32 (UMCTL2_ADDR_BASE+0x0198 , 0x07217111);
    WRITE32 (UMCTL2_ADDR_BASE+0x01a0 , 0x00040003);
    WRITE32 (UMCTL2_ADDR_BASE+0x01a4 , 0x007f008d);
    WRITE32 (UMCTL2_ADDR_BASE+0x01a8 , 0x00000000);
    WRITE32 (UMCTL2_ADDR_BASE+0x01b0 , 0x00000001);
    //    WRITE32 (UMCTL2_ADDR_BASE+0x0200 , 0x00001f1f);  // ADDRMAP0
    //    WRITE32 (UMCTL2_ADDR_BASE+0x0204 , 0x00080808);
    //    WRITE32 (UMCTL2_ADDR_BASE+0x0208 , 0x00000000);
    //    WRITE32 (UMCTL2_ADDR_BASE+0x020c , 0x00000000);
    //    WRITE32 (UMCTL2_ADDR_BASE+0x0210 , 0x00000f0f);
    //    WRITE32 (UMCTL2_ADDR_BASE+0x0214 , 0x07070707);
    //    WRITE32 (UMCTL2_ADDR_BASE+0x0218 , 0x0f0f0707);
    //    WRITE32 (UMCTL2_ADDR_BASE+0x0224 , 0x07070707);
    //    WRITE32 (UMCTL2_ADDR_BASE+0x0228 , 0x07070707);
    //    WRITE32 (UMCTL2_ADDR_BASE+0x022c , 0x00000007);
    ADDR_MAP();

    WRITE32 (UMCTL2_ADDR_BASE+0x0240 , 0x06000604);
    WRITE32 (UMCTL2_ADDR_BASE+0x0244 , 0x00000001);
    WRITE32 (UMCTL2_ADDR_BASE+0x0250 , 0x2a861f05);
    WRITE32 (UMCTL2_ADDR_BASE+0x0254 , 0x00000006);
    WRITE32 (UMCTL2_ADDR_BASE+0x025c , 0x040000c8);
    WRITE32 (UMCTL2_ADDR_BASE+0x0264 , 0x040000c9);
    WRITE32 (UMCTL2_ADDR_BASE+0x026c , 0x040000c8);
    WRITE32 (UMCTL2_ADDR_BASE+0x0274 , 0x00000764);
    WRITE32 (UMCTL2_ADDR_BASE+0x0278 , 0x00000154);
    WRITE32 (UMCTL2_ADDR_BASE+0x0300 , 0x00000010);
    WRITE32 (UMCTL2_ADDR_BASE+0x0304 , 0x00000000);
    WRITE32 (UMCTL2_ADDR_BASE+0x030c , 0x00000000);
    WRITE32 (UMCTL2_ADDR_BASE+0x0320 , 0x00000001);
    WRITE32 (UMCTL2_ADDR_BASE+0x0400 , 0x00000010);
    WRITE32 (UMCTL2_ADDR_BASE+0x0404 , 0x00004080);
    WRITE32 (UMCTL2_ADDR_BASE+0x0408 , 0x00004080);
    WRITE32 (UMCTL2_ADDR_BASE+0x04b4 , 0x00004081);
    WRITE32 (UMCTL2_ADDR_BASE+0x04b8 , 0x00004081);
    WRITE32 (UMCTL2_ADDR_BASE+0x0564 , 0x00004082);
    WRITE32 (UMCTL2_ADDR_BASE+0x0568 , 0x00004082);
    WRITE32 (UMCTL2_ADDR_BASE+0x0614 , 0x00004083);
    WRITE32 (UMCTL2_ADDR_BASE+0x0618 , 0x00004083);
    WRITE32 (UMCTL2_ADDR_BASE+0x0490 , 0x00000001);
    WRITE32 (UMCTL2_ADDR_BASE+0x0494 , 0x02100053);
    WRITE32 (UMCTL2_ADDR_BASE+0x0498 , 0x00ff00ff);
    WRITE32 (UMCTL2_ADDR_BASE+0x049c , 0x00100005);
    WRITE32 (UMCTL2_ADDR_BASE+0x04a0 , 0x000000ff);
    WRITE32 (UMCTL2_ADDR_BASE+0x0540 , 0x00000001);
    WRITE32 (UMCTL2_ADDR_BASE+0x0544 , 0x02100053);
    WRITE32 (UMCTL2_ADDR_BASE+0x0548 , 0x00ff00ff);
    WRITE32 (UMCTL2_ADDR_BASE+0x054c , 0x00100005);
    WRITE32 (UMCTL2_ADDR_BASE+0x0550 , 0x000000ff);
    WRITE32 (UMCTL2_ADDR_BASE+0x05f0 , 0x00000001);
    WRITE32 (UMCTL2_ADDR_BASE+0x05f4 , 0x02100053);
    WRITE32 (UMCTL2_ADDR_BASE+0x05f8 , 0x00ff00ff);
    WRITE32 (UMCTL2_ADDR_BASE+0x05fc , 0x00100005);
    WRITE32 (UMCTL2_ADDR_BASE+0x0600 , 0x000000ff);
    WRITE32 (UMCTL2_ADDR_BASE+0x06a0 , 0x00000001);
    WRITE32 (UMCTL2_ADDR_BASE+0x06a4 , 0x02100053);
    WRITE32 (UMCTL2_ADDR_BASE+0x06a8 , 0x00ff00ff);
    WRITE32 (UMCTL2_ADDR_BASE+0x06ac , 0x00100005);
    WRITE32 (UMCTL2_ADDR_BASE+0x06b0 , 0x000000ff);
    WRITE32 (UMCTL2_ADDR_BASE+0x0750 , 0x00000001);
    WRITE32 (UMCTL2_ADDR_BASE+0x0754 , 0x02100053);
    WRITE32 (UMCTL2_ADDR_BASE+0x0758 , 0x00ff00ff);
    WRITE32 (UMCTL2_ADDR_BASE+0x075c , 0x00100005);
    WRITE32 (UMCTL2_ADDR_BASE+0x0760 , 0x000000ff);
    WRITE32 (UMCTL2_ADDR_BASE+0x0060 , 0x00000000);
    WRITE32 (UMCTL2_ADDR_BASE+0x0304 , 0x00000000);
    WRITE32 (UMCTL2_ADDR_BASE+0x0030 , 0x00000008);
    WRITE32 (UMCTL2_ADDR_BASE+0x0320 , 0x00000000);
    WRITE32 (UMCTL2_ADDR_BASE+0x01b0 , 0x00000000);

    //// step 2 : Deassert core_ddrc_rstn (according to reference test case)
    for (i = 0; i < chs; i++) 
    {
        WRITE32(0x4008c000 + (i * 0x400), 0x00);    // release core/pub apb/port 0/1 reset 
    }

    acu_pub_phy_fpga_init(PUB_ADDR_BASE);
    WRITE32(SWCTL, 0x00000000); // set to 0

    //polling dfi_init_complete from pub to umctl2 due to after dram initialization done, dfi_complete will change to 1
    // polling bit[0]= 1 (change from 0 to 1)
    for (i = 0; i < chs; i++) 
    {
        WRITE32(0x40080420, i); // dram_sel 
        while((READ32(DFISTAT) & 0x1) != 0x1) ;
    }
    //acu_pub_phy_fpga_training();

    WRITE32(UMCTL2_ADDR_BASE + 0x01b0 , 0x00000001);
    WRITE32(UMCTL2_ADDR_BASE + 0x0320 , 0x00000001);

    for (i = 0; i < chs; i++) 
    {
        WRITE32(0x40080420, i); // dram_sel 
        while((READ32(SWSTAT) & 0x1) != 0x1) ;
        while((READ32(STAT) & 0x3) != 0x1) ;
    }

    WRITE32(UMCTL2_ADDR_BASE + 0x0030 , 0x00000008);
    WRITE32(UMCTL2_ADDR_BASE + 0x01b0 , 0x00000000);
    WRITE32(UMCTL2_ADDR_BASE + 0x0320 , 0x00000001);

    ddr_fpga_training ();
}

static void ddr_fpga_training(void) 
{
    int i = 2, temp = 0;
    int dat0 = 0, dat1 = 0, dat2 = 0, dat3 = 0;

    DEBUG_MSG("DDR M3 training start!"LF);

    WRITE32(0xa0000000,0x12345678); 
    WRITE32(0xa0000004,0x9abcdef0);
    WRITE32(0xa0000008,0x55555555); 
    WRITE32(0xa000000c,0xaaaaaaaa); 
    WRITE32(0xa0000010,0x55555555);
    WRITE32(0xa0000014,0xaaaaaaaa); 
    WRITE32(0xa0000018,0x11223344);
    WRITE32(0xa000001c,0x55667788);

    while (i < 8) 
    {
        // set DFI_READ_DELAY_RANK_0 & FCLK_READ_DELAY_RANK_1
        temp = ((i & 0xf) << 28) | ((i & 0xf) << 24) | ((i & 0xf) << 20) | ((i & 0xf) << 16) | ((i & 0xf) << 12) | ((i & 0xf) << 8) | ((i & 0xf) << 4) | ((i & 0xf)) ;
        WRITE32(PUB_ADDR_BASE + 0x34, temp); 
        WRITE32(PUB_ADDR_BASE + 0x44, temp); 

        dat0 = READ32(0xa0000000);
        dat1 = READ32(0xa0000004);
        dat2 = READ32(0xa0000008);
        dat3 = READ32(0xa000000c);
        if ((dat0 == 0x12345678) && (dat1 == 0x9abcdef0) && (dat2 == 0x55555555) && (dat3 == 0xaaaaaaaa)) 
        {
            DEBUG_MSG("DDR M3 training pass!"LF);
            break;
        } 
        i++;
    }
    DEBUG_MSG("DDR M3 training done!"LF);
}

