#include "acu_ddr_init_fpga.h"

void DDRC_FPGA_x8_Init(int chs);

void DDRC_FPGAInit(void)
{
    uint8_t i = 0;
    uint32_t TempSet = 0;
    
    /* DDRC read dram_sel config */
    WRITE_REG(RST_SC->DDR_RCFG, 0x0);

    /* DDRC write dram_wcfg config */
    for (i = 0; i < DDRC_NUMBER; i++) 
    {
        TempSet |= (0x1 << i);
    }
    WRITE_REG(RST_SC->DDR_WCFG, TempSet);

    /* DDRC system management config */
    for (i = 0; i < DDRC_NUMBER; i++) 
    {
        /* set pub address non-compress mode */
        WRITE32(0x4008c024 + (i * 0x400), 0x4);
        /* release clock */
        WRITE32(0x4008c004 + (i * 0x400), 0x3f);
        /* release pubphy pwrokin */
        WRITE32(0x4008c000 + (i * 0x400), 0x1f);
        /* release umctl2 apb/debug reset */
        WRITE32(0x4008c000 + (i * 0x400), 0x13);
    }

    DDRC_FPGA_x8_Init(DDRC_NUMBER);
}

void DDRC_FPGA_x8_Init(int chs)
{
    int i = 0;

    /////////////////////////////////////////////
    // step 1 : Program the DWC_ddr_umctl2 registers 
    WRITE32(              DBG1, 0x00000001); 
    WRITE32(            PWRCTL, 0x00000001); 
    WRITE32(              MSTR, 0x80040601); 
    WRITE32(            PWRCTL, 0x000000a0); 
    WRITE32(            PWRTMG, 0x00030005); 
    WRITE32(           HWLPCTL, 0x0aaf0001); 
    WRITE32(          RFSHCTL0, 0x00a0d040); 
    WRITE32(          RFSHCTL3, 0x00000000); 
    WRITE32(           RFSHTMG, 0x0081001b); 
    WRITE32(             INIT0, 0xc0030003); 
    WRITE32(           DIMMCTL, 0x00000000); 

    ////DRAM_prototype_timing
    DRAM_prototype_timing();

    // DFI_config
    WRITE32(           DFITMG0, 0x08050002);    // 0x04928210);  fpga setting
    WRITE32(           DFITMG1, 0x00110101);    // 0x00070303); 
    WRITE32(         DFILPCFG0, 0x06002010); 
    WRITE32(         DFILPCFG1, 0x00000070); 
    WRITE32(           DFIUPD0, 0x60400018); 
    WRITE32(           DFIUPD1, 0x007a00aa); 
    WRITE32(           DFIUPD2, 0x80000000); 
    WRITE32(           DFIMISC, 0x00000049); 
    WRITE32(           DFITMG2, 0x00001210);    // dfi_wrcslat & dfi_rdcslat ???
    WRITE32(           DFITMG3, 0x00000008); 
    WRITE32(            DBICTL, 0x00000001); 
    WRITE32(        DFIPHYMSTR, 0x00000000); 

    //MEMC_BURST_LENGTH=8, MEMC_DRAM_DATA_WIDTH =32, UMCTL2_A_ADDRW = 32, MEMC_FREQ_RATIO=2
    //hif_cmd_addr[36:log2(MEMC_BURST_LENGTH)] = {ARADDR | AWADDR | HADDR} [UMCTL2_A_ADDRW-1:log2(MEMC_BURST_LENGTH)+log2(MEMC_DRAM_DATA_WIDTH/8)]
    //hif_cmd_addr[log2(MEMC_BURST_LENGTH)-1:MEMC_FREQ_RATIO] is internally generated by XPI
    //hif_cmd_addr [MEMC_FREQ_RATIO-1:0] = 0
    //generated :
    //hif_cmd_addr[36:30]   = 0
    //hif_cmd_addr[29:3]    = {ARADDR | AWADDR}[31:5];  // mapping lsb  
    //hif_cmd_addr[2:2]     = internally generated by XPI   // soc[4]
    //hif_cmd_addr[1:0]     = 0                             // soc[3:2]
    //
    //fpga mapping to hif_cmd_addr[28:0] = {row[15:0], bank[2:0], col[9:0]} 
    //axi_addr[30:0] =  {row[15:0], bank[2:0], col[9:0], 2'd0} = 2GB
    //axi_addr[31:0] =  {bank[2], 1'd0, row[15:0], bank[1:0], col[9:0], 2'd0} 
    //                                               
    //bank_b2/1/0, internal base is 4/3/2
    WRITE32(          ADDRMAP1, 0x00190808); //bank[2:0], bank[2] set to hif_cmd_addr[29]
    // bank[2] set to soc address bit[31], which can be set by mpu system management register, 
    // work around for fpga single channel, which can be used as share-AC dual channel(fpga =2GB, interleave for axi port0 & port1, interleave size is 16KB)
    //
    //full bus mode
    //col_b5/4/3/2, internal base is 5/4/3/2, col_b2 always set to 0
    WRITE32(          ADDRMAP2, 0x00000000); 
    //col_b9/8/7/6, internal base is 9/8/7/6
    WRITE32(          ADDRMAP3, 0x00000000); 
    //col_b11/b10, no used, set to 0x1f
    WRITE32(          ADDRMAP4, 0x00001f1f); 
    //row_b11, b2_10, b1, b0, internal base from 6 to 17
    WRITE32(          ADDRMAP5, 0x06060606); 
    //row_b15, b14, b13, b12, internal base from 18 to 21
    WRITE32(          ADDRMAP6, 0x06060606);    
    //
    //row_b17, b16, no used
    WRITE32(          ADDRMAP7, 0x00000f0f); 
    // bg_b1/b0, ddr3 no use
    WRITE32(          ADDRMAP8, 0x00003f3f); 
    //row_b5/4/3/2, only used when row_b2_10 set to 0xf
    WRITE32(          ADDRMAP9, 0x06060606); 
    //row_b9/8/7/6, only used when row_b2_10 set to 0xf
    WRITE32(         ADDRMAP10, 0x06060606); 
    //row_b10, only used when row_b2_10 set to 0xf
    WRITE32(         ADDRMAP11, 0x00000006); 

    //  Port_config
    WRITE32(            ODTCFG, 0x091c0678); 
    WRITE32(            ODTMAP, 0x00000001); 
    WRITE32(             SCHED, 0x119a1500); 
    WRITE32(            SCHED1, 0x00000015); 
    WRITE32(          PERFHPR1, 0x9c00ee3b); 
    WRITE32(          PERFLPR1, 0xc400f97c); 
    WRITE32(           PERFWR1, 0x7b000077); 
    WRITE32(              DBG0, 0x00000015); 
    WRITE32(              DBG1, 0x00000000); 
    WRITE32(            DBGCMD, 0x00000000); 
    WRITE32(             SWCTL, 0x00000001); 
    WRITE32(         POISONCFG, 0x00010001); 
    WRITE32(             PCCFG, 0x00000101); 
    WRITE32(           PCFGR_0, 0x0000224a); 
    WRITE32(           PCFGW_0, 0x00006040); 
    WRITE32(           PCTRL_0, 0x00000001); 
    WRITE32(        PCFGQOS0_0, 0x00110002); 
    WRITE32(        PCFGQOS1_0, 0x0056000e); 
    WRITE32(       PCFGWQOS0_0, 0x01110302); 
    WRITE32(       PCFGWQOS1_0, 0x06c3073a); 
    WRITE32(           PCFGR_1, 0x000022e0); 
    WRITE32(           PCFGW_1, 0x00003221); 
    WRITE32(           PCTRL_1, 0x00000001); 
    WRITE32(        PCFGQOS0_1, 0x00210007); 
    WRITE32(        PCFGQOS1_1, 0x06a70038); 
    WRITE32(       PCFGWQOS0_1, 0x01000904); 
    WRITE32(       PCFGWQOS1_1, 0x023104c8); 
    WRITE32(           PCFGR_2, 0x0000214a); 
    WRITE32(           PCFGW_2, 0x0000218a); 
    WRITE32(           PCTRL_2, 0x00000001); 
    WRITE32(        PCFGQOS0_2, 0x00100006); 
    WRITE32(        PCFGQOS1_2, 0x04ac0276); 
    WRITE32(       PCFGWQOS0_2, 0x00110201); 
    WRITE32(       PCFGWQOS1_2, 0x020e06a8); 
    WRITE32(              PDCH, 0x00000000);    // all set to channel 0

    WRITE32(       DCH1_PWRCTL, 0x000000a0); 
    WRITE32(      DCH1_HWLPCTL, 0x0aaf0001); 
    WRITE32(       DCH1_ODTMAP, 0x00000001); 
    WRITE32(         DCH1_DBG1, 0x00000000); 
    WRITE32(       DCH1_DBGCMD, 0x00000000); 
    WRITE32(            PWRCTL, 0x000000a0); 
    WRITE32(       DCH1_PWRCTL, 0x000000a0); 

    /////////////////////////////////////////////
    //RESET: <aresetn> for Port 2  DEASSERTED
    //RESET: <aresetn> for Port 1  DEASSERTED
    //RESET: <aresetn> for Port 0  DEASSERTED
    //RESET: <core_ddrc_rstn> DEASSERTED
    //
    //// step 2 : Deassert core_ddrc_rstn (according to reference test case)
    for (i=0; i<chs; i++) {
        WRITE32(0x4008c000+(i*0x400),0x03);    // release core/pub apb reset 
    }

    /////////////////////////////////////////////
    WRITE32 (              DBG1, 0x00000000);
    WRITE32 (            PWRCTL, 0x000000a0);
    WRITE32 (            PWRCTL, 0x000000a0);
    WRITE32 (         DCH1_DBG1, 0x00000000);
    WRITE32 (       DCH1_PWRCTL, 0x000000a0);
    WRITE32 (       DCH1_PWRCTL, 0x000000a0);
    WRITE32 (        DFIPHYMSTR, 0x00000000);
    WRITE32 (             SWCTL, 0x00000000);
    WRITE32 (           DFIMISC, 0x00000048);
    WRITE32 (           DFIMISC, 0x00000048);
    WRITE32 (              DBG1, 0x00000002);
    WRITE32 (         DCH1_DBG1, 0x00000002);

    //  step 3   Start PHY initialization by accessing relevant PUB registers 
    //
#ifdef PHY_PLLBYPASS
    READ32( PUB_ADDR_BASE + 0x000200c6*4 , 0x00000008 );    // PllCtrl0
    WRITE32( PUB_ADDR_BASE + 0x000200c6*4 , 0x00000028 );    // PllCtrl0
#endif

    //ddr3_init_dmem(PUB_ADDR_BASE);
    //ddr3_init_imem(PUB_ADDR_BASE);

    acu_pub_phy_fpga_init(PUB_ADDR_BASE);
    WRITE32( 			SWCTL, 0x00000000); // set to 0

    //acu_pub_phy_fpga_training();
    // step 7 : Set DFIMISC.dfi_init_complete_en to 1 
    // DWC_ddr_umctl2 waits for phy_dfi_init_complete to be asserted
    //
    // dfi_init_start trigger from umctl2 to pub
    WRITE32(           DFIMISC , 0x00000068);    // set dfi_init_start = 1
    //polling dfi_init_complete from pub to umctl2
    // polling bit[0]= 1 (change from 0 to 1)
    for (i=0; i<chs; i++) {
        WRITE32(0x40080420, i); // dram_sel 
    while((READ32 (DFISTAT) & 0x1) != 0x1) ;
    }
    WRITE32(           DFIMISC , 0x00000048);    // set dfi_init_start = 0 
    WRITE32(           DFIMISC , 0x00000049);    // set dfi_init_complete_en = 1
    WRITE32(            PWRCTL , 0x00000080); 
    WRITE32(       DCH1_PWRCTL , 0x00000080); 

    // step 8 : Set SWCTL.sw_done to 1 
    WRITE32(             SWCTL , 0x00000001);    // set sw_done =1
    // step 9 : Wait for SWSTAT.sw_done_ack to become 1 
    // wait sw_done_ack = 1
    // polling bit[0]= 1 (change from 0 to 1)
    for (i=0; i<chs; i++) {
        WRITE32(0x40080420,i); // dram_sel 
    while((READ32 (SWSTAT) & 0x1) != 0x1) ;
    }

    // step 10 :    Wait for DWC_ddr_umctl2 to move to “normal” operating mode by monitoring STAT.operating_mode signal 
    // wait normal state = 1
    for (i=0; i<chs; i++) {
        WRITE32(0x40080420, i); // dram_sel 
    while((READ32 (            STAT) & 0x3) != 0x1) ;
    while((READ32 (       DCH1_STAT) & 0x3) != 0x1) ;
    }

    WRITE32(        DFIPHYMSTR , 0x00000000);    // set dfi_phymstr_en   = 0
    WRITE32(             SWCTL , 0x00000000);    // set sw_done = 0
    WRITE32(             INIT0 , 0x00030003); 
    WRITE32(             SWCTL , 0x00000001);    // set sw_done = 1
    // wait sw_done_ack = 1
    for (i=0; i<chs; i++) {
        WRITE32(0x40080420, i); // dram_sel 
    while((READ32 (            SWSTAT) & 0x1) != 0x1) ;
    }

    WRITE32(              DBG1 , 0x00000000); 
    WRITE32(         DCH1_DBG1 , 0x00000000); 
    WRITE32(            PWRCTL , 0x00000080); 
    WRITE32(       DCH1_PWRCTL , 0x00000080); 
    WRITE32(            PWRCTL , 0x00000080); 
    WRITE32(       DCH1_PWRCTL , 0x00000080); 
    WRITE32(           PCTRL_0 , 0x00000001);    // port enable
    WRITE32(           PCTRL_1 , 0x00000001); 
    WRITE32(           PCTRL_2 , 0x00000001); 

    /* simple test */
    WRITE32(0xa0000000, 0x12345678);
    WRITE32(0xa0000004, 0x9abcdef0);
    WRITE32(0xa0000008, 0x11223344); 
    WRITE32(0xa000000c, 0x55667788);
    for (i = 0; i < DDRC_NUMBER; i++) 
    {
        WRITE32(0x40080420, i); // dram_sel 

        if(i==0) DEBUG_MSG("DDRC#0 read test. \n"); 
        else if(i==1) DEBUG_MSG("DDRC#1 read test. \n"); 
        else if(i==2) DEBUG_MSG("DDRC#2 read test. \n"); 
        else if(i==3) DEBUG_MSG("DDRC#3 read test. \n"); 
        else if(i==4) DEBUG_MSG("DDRC#4 read test. \n"); 
        else if(i==5) DEBUG_MSG("DDRC#5 read test. \n"); 
        else if(i==6) DEBUG_MSG("DDRC#6 read test. \n"); 
        else if(i==7) DEBUG_MSG("DDRC#7 read test. \n"); 

        if(READ32(0xa0000000) == 0x12345678) {
            DEBUG_MSG("DDR read data = 0x12345678\n");
        } else {
            DEBUG_MSG("DDR read data Error! \r\n");
        }   

        if(READ32(0xa0000004) == 0x9abcdef0) {
            DEBUG_MSG("DDR read data = 0x9abcdef0\n");
        } else {
            DEBUG_MSG("DDR read data Error! \r\n");
        }   
    }
}

